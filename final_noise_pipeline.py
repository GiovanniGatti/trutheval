# -*- coding: utf-8 -*-
"""FINAL_NOISE_PIPELINE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gb11oIi8ap9qgz5WubTATyBNPCelSVTH
"""

!pip install openai==0.28

import openai
import random
import json
import math

openai.api_key = "YOUR_OPENAI_API_KEY"

def generate_response(prompt):
    """
    Calls the OpenAI ChatCompletion endpoint and returns the response text.
    """
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ]
    )
    return response["choices"][0]["message"]["content"].strip()

def generate_a0(ground_truth):

    prompt = (
        "Rewrite the provided sentence to express the same idea in slightly different words while preserving "
        "full accuracy, completeness, and meaning. Ensure the content remains faithful to the original and includes "
        "all key details.\n\n"
        f"Original:\n\"{ground_truth}\"\n\n"
        "Paraphrased version:"
    )
    return generate_response(prompt)

def bracket_and_list_factual_data(a0_text):

    prompt = (
        "Take the following text and put each piece of factual data between square brackets. "
        "Then return ONLY a JSON array of these bracketed items. Example output:\n"
        "[\"[Fuel]\", \"[1983]\", \"[Mr. John Colman]\"]\n\n"
        f"Text:\n\"{a0_text}\"\n\n"
        "Output ONLY the JSON array, no extra text."
    )
    response_text = generate_response(prompt)

    try:
        factual_data_list = json.loads(response_text)
    except json.JSONDecodeError:
        # If parsing fails, fallback to empty list
        print("WARNING: Could not parse JSON from model. Response was:", response_text)
        factual_data_list = []

    return factual_data_list

def generate_noisy_version(a0_text, items_to_change):

    if not items_to_change:
        return a0_text  # no changes

    bracketed_items_str = ", ".join(items_to_change)
    print(f"Items to change: {bracketed_items_str}")

    prompt = (
        "You must ONLY modify the following bracketed items in the original text, making them slightly incorrect "
        "or omitting them entirely, but always in a realistic and serious manner (no fantasy or humorous content). "
        "All other parts of the text MUST remain unchanged. "
        "Retain the same sentence structure, punctuation, and style wherever possible. "
        "If a bracketed element is a date, change it to a close/near date (e.g., 1809 -> 1810). "
        "If it's a location, substitute it with a plausible alternative in the same era. "
        "If it's a name, role, or numeric value, change it to something similar but not identical. "
        "Remove square brackets [ ] from any changed words.\n\n"
        "Original text:\n"
        f"{a0_text}\n\n"
        "Items to subtly change:\n"
        f"{bracketed_items_str}\n\n"
        "Now produce the final text with only these realistic, minimal changes:"
    )

    noisy_text = generate_response(prompt)
    # Remove any stray brackets
    noisy_text = noisy_text.replace("[", "").replace("]", "")
    return noisy_text.strip()

def main_pipeline(data):

    results = []

    for entry in data:
        question = entry["question"]
        ground_truth = entry["ground_truth"]

        a0 = generate_a0(ground_truth)

        factual_data = bracket_and_list_factual_data(a0)

        random.shuffle(factual_data)

        answers = {}
        answers["A0"] = a0
        fractions = [0.25, 0.50, 0.75, 1.0]

        for i, fraction in enumerate(fractions, start=1):
            num_items_to_change = math.ceil(len(factual_data) * fraction)
            items_for_level = factual_data[:num_items_to_change]
            noisy_version = generate_noisy_version(a0, items_for_level)
            answers[f"A{i}"] = noisy_version

        # final entry
        result_entry = {
            "question": question,
            "ground_truth": ground_truth,
            "answers": answers
        }
        results.append(result_entry)

    return results


if __name__ == "__main__":

    with open("gold_dataset.json", "r", encoding="utf-8") as f:
        data = json.load(f)  # data must be a list of {"question": ..., "ground_truth": ...}

    results = main_pipeline(data)

    with open("final_output.json", "w", encoding="utf-8") as f:
        json.dump(results, f, indent=4, ensure_ascii=False)

    print(json.dumps(results, indent=4, ensure_ascii=False))